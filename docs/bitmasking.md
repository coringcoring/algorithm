# BITMASKING
정수의 이진수 표현을 자료구조로 쓰는 기법    
더 빠른 수행 시간, 간결한 코드, 적은 메모리 사용이 가능해짐 

## 비트 연산자 
1. AND 연산자: a & b
2. OR 연산자: a | b
3. XOR 연산자: a ^ b
4. NOT 연산자: ~a
5. SHIFT 연산자: a << b, a >> b

## 집합의 표현 
비트마스크를 사용하면 집합을 쉽게 표현 가능.     
원소 추가, 삭제 등의 연산을 빠르게 수행 가능 
* ex) {A, B, C, D, E, F, G} 의 집합이 있다면..
  * 7개의 원소가 존재 = 7개의 비트로 집합 표현 가능
  * 각 원소마다 비트를 하나씩 대응하여 원소가 존재하면 1, 아니면 0
  * { A } 라는 부분집합은 64 = 1000000(2) 로 표현 가능
  * { C, F } 라는 부분집합은 18=0010010(2)로 표현 가능 

## 원소 추가 
* 현재 상태를 cur라 하고, p번 원소를 추가한다면 -> cur에서 p번 비트를 1로 바꾸어줘야함
* a | b를 통해 해결 가능
```
cur= cur | (1<<p)
```

## 원소 삭제 
* 현재 상태를 cur, p번 원소를 삭제한다면 -> cur에서 p번 비트를 0으로 바꿔줘야함 
* a & b를 사용
```
cur= cur & ~(1<<p)
```

## 원소 토글 
* 토글 연산?: 특정 원소의 비트가 1이면 0으로, 0이면 1로 바꾸는 연산 = 특정 원소가 있으면 삭제하고, 없으면 추가하는 연산
```
cur= cur ^ (1<<p)
```

## 집합 연산 
* 합집합, 교집합, 차집합 등등을 비트마스킹을 사용해 구현 가능
* 합집합: a | b
* 교집합: a & b
* 차집합: a & ~b
* a와 b 중 하나에만 포함된 원소들의 집합: a ^ b


## 집합 크기 구하기 
* 1로 켜져있는 비트의 수를 count 해야함 -> 모든 비트 순회해야함
* 이를 재귀적으로 구현 가능
```
int bitCount(int x){
    if(x==0) return 0;
    return x%2 + bitCount(x/2);
}
``` 
* x%2를 하면 마지막 비트를 얻고, x/2는 마지막 비트를 삭제



### References
* https://travelbeeee.tistory.com/451
